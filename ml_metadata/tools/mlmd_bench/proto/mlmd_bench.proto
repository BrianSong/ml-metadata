/* Copyright 2020 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

syntax = "proto2";

package ml_metadata;

import "ml_metadata/proto/metadata_store.proto";

// Input configurations for mlmd_bench.
message MLMDBenchConfig {
  // Connection configuration (sqlite, mysql...) for mlmd_bench.
  optional ConnectionConfig mlmd_config = 1;
  // An array of workload configurations specified by the users.
  repeated WorkloadConfig workload_configs = 2;
  // Multi-threaded environment configuration for executing the workloads.
  optional ThreadEnvConfig thread_env_config = 3;
}

// A uniform distribution within range [minimum, maximum].
message UniformDistribution {
  optional int64 minimum = 1;
  optional int64 maximum = 2;
}

// Create and update types: ArtifactTypes / ExecutionTypes / ContextTypes.
message FillTypesConfig {
  // The FillTypesConfig can be set to insert or update types.
  optional bool update = 1;
  enum Specification {
    ARTIFACT_TYPE = 0;
    EXECUTION_TYPE = 1;
    CONTEXT_TYPE = 2;
  }
  // Indicates which types to be filled.
  optional Specification specification = 2;
  // Specifies the number of properties for each type, modeled by a
  // uniform distribution.
  optional UniformDistribution num_properties = 3;
}

// Create and update nodes: Artifacts / Executions / Contexts
message FillNodesConfig {
  // The FillNodesConfig can be set to insert or update mode
  optional bool update = 1 [default = false];
  enum Specification {
    ARTIFACT = 0;
    EXECUTION = 1;
    CONTEXT = 2;
  }
  // Indicate which type of nodes to be filled
  optional Specification specification = 2;
  // Specify the number of properties for each node
  // It can be modeled by a uniform distribution
  optional UniformDistribution num_properties = 3;
  // Specify the string length for each property of the current node.
  // It can be modeled by a uniform distribution
  optional UniformDistribution string_value_bytes = 4;
}

// Create context edges: Attributions / Associations
message FillContextEdgesConfig {
  enum Specification {
    ATTRIBUTION = 0;
    ASSOCIATION = 1;
  }
  // Indicate which type of context's edges to be filled
  optional Specification specification = 1;
} 

// Create input / output events.
message FillEventsConfig {
  enum Specification {
    INPUT = 0;
    OUTPUT = 1;
  }
  // Indicate the type (input / output) of the event
  optional Specification specification = 1;
}

// Read types: ArtifactTypes / ExecutionTypes / ContextTypes.
message ReadTypesConfig {
  enum Specification {
    ALL_ARTIFACT_TYPES = 0;
    ALL_EXECUTION_TYPES = 1;
    ALL_CONTEXT_TYPES = 2;
    ARTIFACT_TYPES_BY_ID = 3;
    EXECUTION_TYPES_BY_ID = 4;
    CONTEXT_TYPES_BY_ID = 5;
    ARTIFACT_TYPE_BY_NAME = 6;
    EXECUTION_TYPE_BY_NAME = 7;
    CONTEXT_TYPE_BY_NAME = 8;
  }
  // Indicate the specification to get types
  optional Specification specification = 1;
}

// Read nodes: Artifacts / Executions / Contexts by their properties.
message ReadNodesByPropertiesConfig {
  enum Specification {
    ARTIFACTS_BY_ID = 0;
    EXECUTIONS_BY_ID = 1;
    CONTEXTS_BY_ID = 2;
    ARTIFACTS_BY_TYPE = 3;
    EXECUTIONS_BY_TYPE = 4;
    CONTEXTS_BY_TYPE = 5;
    ARTIFACT_BY_TYPE_AND_NAME = 6;
    EXECUTION_BY_TYPE_AND_NAME = 7;
    CONTEXT_BY_TYPE_AND_NAME = 8;
  }
  // Indicate what properties (id, type, name, etc.)  
  // should be used to get nodes (artifact, execution, context)
  optional Specification specification = 1;
}

// Read nodes by traverse between Artifact/Execution and Contexts.
message ReadNodesViaContextEdgesConfig {
  enum Specification {
    CONTEXTS_BY_ARTIFACT = 0;
    CONTEXTS_BY_EXECUTION = 1;
    ARTIFACTS_BY_CONTEXT = 2;
    EXECUTIONS_BY_CONTEXT = 5;
  }
  // Indicate which transverse API is used to get nodes
  optional Specification specification = 1;
}

// Read Events.
message ReadEventsConfig {
  enum Specification {
    EVENTS_BY_ARTIFACT_IDS = 0;
    EVENTS_BY_EXECUTION_IDS = 1;
  }
  // Indicate which specification is used to get events
  optional Specification specification = 1;
}

// The mlmd_bench workload config.
message WorkloadConfig {
  oneof workload_config {
    FillTypesConfig fill_types_config = 1;
    FillNodesConfig fill_nodes_config = 2;
    FillContextEdgesConfig fill_context_edges_config = 3;
    FillEventsConfig fill_events_config = 4;
    ReadTypesConfig read_types_config = 5;
    ReadNodesByPropertiesConfig read_nodes_by_properties_config = 6;
    ReadNodesViaContextEdgesConfig read_nodes_via_context_edges_config = 7;
    ReadEventsConfig read_event_config = 8;
  }
  // The number of operations to be run in parallel.
  optional int64 num_operations = 9;
}

// The configuration for the multi-threaded environment which executes the
// workloads.
message ThreadEnvConfig {
  // The number of threads in the thread pool.
  optional int32 num_threads = 1;
}

// The output report for mlmd_bench.
message MLMDBenchReport {
  // A list of summaries for the array of workload configurations.
  repeated WorkloadConfigResult summaries = 1;
}

// The performance result for each workload configuration.
message WorkloadConfigResult {
  // The workload configuration that this result belongs to.
  optional WorkloadConfig workload_config = 1;
  // Microsecond / operations for the current workload_config.
  optional double microseconds_per_operation = 2;
  // Bytes / second for the current workload_config.
  optional double bytes_per_second = 3;
}
